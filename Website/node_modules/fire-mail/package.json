{
  "_args": [
    [
      {
        "raw": "fire-mail@^0.0.0",
        "scope": null,
        "escapedName": "fire-mail",
        "name": "fire-mail",
        "rawSpec": "^0.0.0",
        "spec": ">=0.0.0 <0.0.1",
        "type": "range"
      },
      "/Users/ryanoconnell/Desktop/Web_Capstone/Species_Web_Repo/species-website"
    ]
  ],
  "_from": "fire-mail@>=0.0.0 <0.0.1",
  "_id": "fire-mail@0.0.0",
  "_inCache": true,
  "_location": "/fire-mail",
  "_npmUser": {
    "name": "gintellect",
    "email": "david@gintellect.com"
  },
  "_npmVersion": "1.2.32",
  "_phantomChildren": {
    "directmail": "0.1.8",
    "faye-websocket": "0.11.1",
    "he": "0.3.6",
    "mailcomposer": "0.2.12",
    "public-address": "0.1.2",
    "readable-stream": "2.2.6",
    "simplesmtp": "0.3.35"
  },
  "_requested": {
    "raw": "fire-mail@^0.0.0",
    "scope": null,
    "escapedName": "fire-mail",
    "name": "fire-mail",
    "rawSpec": "^0.0.0",
    "spec": ">=0.0.0 <0.0.1",
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/fire-mail/-/fire-mail-0.0.0.tgz",
  "_shasum": "f42332d0a862e029d84e144a3d77d54acb6570c2",
  "_shrinkwrap": null,
  "_spec": "fire-mail@^0.0.0",
  "_where": "/Users/ryanoconnell/Desktop/Web_Capstone/Species_Web_Repo/species-website",
  "author": {
    "name": "David Bochenski"
  },
  "bugs": {
    "url": "https://github.com/gintellect/fire-mail/issues"
  },
  "dependencies": {
    "coffee-script": "~1.6.3",
    "firebase": "~0.6.9",
    "firebase-token-generator": "~0.1.4",
    "nconf": "~0.6.8",
    "nodemailer": "~0.5.5"
  },
  "description": "Waits for entries at a firebase location and then sends details on by email",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "f42332d0a862e029d84e144a3d77d54acb6570c2",
    "tarball": "https://registry.npmjs.org/fire-mail/-/fire-mail-0.0.0.tgz"
  },
  "homepage": "https://github.com/gintellect/fire-mail#readme",
  "keywords": [
    "firebase",
    "email",
    "contact",
    "form"
  ],
  "license": "MIT",
  "main": "index.coffee",
  "maintainers": [
    {
      "name": "gintellect",
      "email": "david@gintellect.com"
    }
  ],
  "name": "fire-mail",
  "optionalDependencies": {},
  "readme": "Fire-Mail\n==========\n\n**Fire Mail** is an easy to use npm module to send e-mail notifications based on entries in firebase.\n\nYou might want this if you have a client side web app with a contact us form, but still want to serve it over Amazon S3 for example.\n\n\n## Notes and information\n\n### Installation\n\n`npm install fire-mail`\n\n\n## TL;DR Usage Example\n\n``` javascript\nvar fireMail = require(\"fire-mail\");\n\n```\n\n### Configuration\nThere are three ways you can load in the configuration options\n\n* config.json\n* options object\n* firebase ref\n\n### Templates\n\nTo use Nodemailer with templates, please see documentation for these projects.\n\n * [swig-email-templates](https://github.com/superjoe30/swig-email-templates) - swig, template inheritance, dummy context\n * [node-email-templates](https://github.com/niftylettuce/node-email-templates) - ejs\n\n\nThis is a complete example to send an e-mail with plaintext and HTML body\n\n```javascript\nvar nodemailer = require(\"nodemailer\");\n\n// create reusable transport method (opens pool of SMTP connections)\nvar smtpTransport = nodemailer.createTransport(\"SMTP\",{\n    service: \"Gmail\",\n    auth: {\n        user: \"gmail.user@gmail.com\",\n        pass: \"userpass\"\n    }\n});\n\n// setup e-mail data with unicode symbols\nvar mailOptions = {\n    from: \"Fred Foo ✔ <foo@blurdybloop.com>\", // sender address\n    to: \"bar@blurdybloop.com, baz@blurdybloop.com\", // list of receivers\n    subject: \"Hello ✔\", // Subject line\n    text: \"Hello world ✔\", // plaintext body\n    html: \"<b>Hello world ✔</b>\" // html body\n}\n\n// send mail with defined transport object\nsmtpTransport.sendMail(mailOptions, function(error, response){\n    if(error){\n        console.log(error);\n    }else{\n        console.log(\"Message sent: \" + response.message);\n    }\n\n    // if you don't want to use this transport object anymore, uncomment following line\n    //smtpTransport.close(); // shut down the connection pool, no more messages\n});\n```\n\nSee also the [examples folder](https://github.com/andris9/Nodemailer/tree/master/examples)\nfor full featured examples\n\n## Installation\n\nInstall through NPM\n\n```\nnpm install nodemailer\n```\n\n## Usage\n\nInclude the module\n\n```javascript\nvar nodemailer = require(\"nodemailer\");\n```\n\nAn e-mail can be sent with `sendMail(mailOptions[, callback])` command\n\n```javascript\ntransport.sendMail(mailOptions, callback);\n```\n\nWhere\n\n  * `transport` is a transport object created from the `nodemailer.createTransport` method\n  * **mailOptions** defines the e-mail (set its subject, body text, receivers etc.), see [E-mail Message Fields](#e-mail-message-fields) for details\n  * **callback** is the callback function that will be run after the e-mail is sent or the sending failed (see [Return callback](#return-callback) for details)\n\n## Setting up a transport method\n\nBefore you can send any e-mails you need to set up a transport method. This can\nbe done with `nodemailer.createTransport(type, options)` where `type` indicates\nthe transport protocol and `options` defines how it is used.\n\n```javascript\nvar transport = nodemailer.createTransport(\"SMTP\", {smtp_options});\n```\n\nThe same transport object can and should be reused several times.\n\nWhen the transport method is defined, it can be used to send e-mail with `sendMail`\n\n```javascript\nvar transport = nodemailer.createTransport(\"SMTP\", {smtp_options});\n\ntransport.sendMail({\n    from: \"sender@tr.ee\",\n    to: \"receiver@tr.ee\"\n    ...\n});\n```\n\n### Possible transport methods\n\nRequired `type` parameter can be one of the following:\n\n  * **SMTP** for using SMTP\n  * **SES** for using Amazon SES\n  * **Sendmail** for utilizing systems *sendmail* command\n\n### Setting up SMTP\n\nSMTP is different from the other transport mechanisms, as in its case a connection\npool is created. All the connections try to stay alive as long as possible and\nare reusable to minimize the protocol overhead delay - for example setting up\nTLS for authenticating is relatively lengthy process (in CPU terms, not by human\nterms), you do not want to do it several times.\n\nPossible SMTP options are the following:\n\n * **service** - an optional well known service identifier (\"Gmail\", \"Hotmail\" etc., see [Well known Services](#well-known-services-for-smtp) for a list of supported services) to auto-configure host, port and secure connection settings\n * **host** - hostname of the SMTP server (defaults to \"localhost\", not needed with `service`)\n * **port** - port of the SMTP server (defaults to 25, not needed with `service`)\n * **secureConnection** - use SSL (default is `false`, not needed with `service`). If you're using port 587 then keep `secureConnection` false, since the connection is started in insecure plain text mode and only later upgraded with STARTTLS\n * **name** - the name of the client server (defaults to machine name)\n * **auth** - authentication object as `{user:\"...\", pass:\"...\"}` or  `{XOAuth2: {xoauth2_options}}` or  `{XOAuthToken: \"base64data\"}`\n * **ignoreTLS** - ignore server support for STARTTLS (defaults to `false`)\n * **debug** - output client and server messages to console\n * **maxConnections** - how many connections to keep in the pool (defaults to 5)\n * **maxMessages** - limit the count of messages to send through a single connection (no limit by default)\n\nExample:\n\n```javascript\nvar transport = nodemailer.createTransport(\"SMTP\", {\n    service: \"Gmail\",\n    auth: {\n        user: \"gmail.user@gmail.com\",\n        pass: \"userpass\"\n    }\n});\n```\n\nor the same without `service` parameter\n\n```javascript\nvar transport = nodemailer.createTransport(\"SMTP\", {\n    host: \"smtp.gmail.com\", // hostname\n    secureConnection: true, // use SSL\n    port: 465, // port for secure SMTP\n    auth: {\n        user: \"gmail.user@gmail.com\",\n        pass: \"userpass\"\n    }\n});\n```\n\n**NB!** if you want to close the pool (cancel all open connections) you can use `transport.close()`\n\n```javascript\n\nvar transport = nodemailer.createTransport(\"SMTP\",{});\n...\ntransport.close(); // close the pool\n```\n\n\n#### SMTP XOAUTH and token generation\n\n##### XOAUTH2\n\n**nodemailer** supports XOAUTH2 authentication protocol. To use this you need to obtain a Client ID and a Client Secret from [Google API Console](https://code.google.com/apis/console) (Open \"API Access\" and create \"Client ID for web applications\") and then request a refresh token for an user. See [Google OAuth 2.0 Offline Access](https://developers.google.com/accounts/docs/OAuth2WebServer#offline) for more information.\n\nOnce you have obtained the Client ID, Client Secret and a Refresh Token for an user, you can use these values to send mail on behalf of the user.\n\n```javascript\nvar transportOptions = {\n    ...,\n    auth: {\n        XOAuth2: {\n            user: \"example.user@gmail.com\",\n            clientId: \"8819981768.apps.googleusercontent.com\",\n            clientSecret: \"{client_secret}\",\n            refreshToken: \"1/xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI\",\n            accessToken: \"vF9dft4qmTc2Nvb3RlckBhdHRhdmlzdGEuY29tCg==\",\n            timeout: 3600\n        }\n    }\n}\n```\n\n`accessToken` and `timeout` values are both optional. If XOAUTH2 login fails a new access token is generated automatically and the login is retried.\n\n##### XOAUTH\n\nOlder XOAUTH is also supported by **nodemailer** for SMTP. XOAUTH is based on OAuth protocol 1.0 and is considered deprecated.\n\nTo use this, include `XOAuthToken` option in `auth` instead of the regular `user` and `pass`.\n\n```javascript\nvar transportOptions = {\n    ...,\n    auth: {\n        XOAuthToken: \"R0VUIGh0dHBzOi8vbWFpbC5nb29....\"\n    }\n}\n```\n\n**nodemailer** includes also built in XOAUTH token generator which can be used\nwith `nodemailer.createXOAuthGenerator()`. The function is preconfigured for\nGmail, so in this case only mandatory options are `user`, `token` and `tokenSecret`.\n\n```javascript\nvar XOAuthTokenGenerator = nodemailer.createXOAuthGenerator({\n        user: \"test.nodemailer@gmail.com\",\n        // requestUrl: \"https://oauth.access.point\",\n        // consumerKey: \"anonymous\",\n        // consumerSecret: \"anonymous\",\n        token: \"1/O_HgoO4h2uOUfpus0V--7mygICXrQQ0ZajB3ZH52KqM\",\n        tokenSecret: \"_mUBkIwNPnfQBUIWrJrpXJ0c\"\n    });\n```\n\nOne of `user` or `requestUrl` is mandatory. `consumerKey` and `consumerSecret` both\ndefault to `\"anonymous\"`.\n\n```javascript\nvar transportOptions = {\n    service: \"Gmail\",\n    auth: {\n        XOAuthToken: nodemailer.createXOAuthGenerator({\n            user: \"test.nodemailer@gmail.com\",\n            token: \"1/O_HgoO4h2uOUfpus0V--7mygICXrQQ0ZajB3ZH52KqM\",\n            tokenSecret: \"_mUBkIwNPnfQBUIWrJrpXJ0c\"\n        })\n    }\n}\n```\n\n### Setting up SES\n\nSES is actually a HTTP based protocol, the compiled e-mail and related info\n(signatures and such) are sent as a HTTP request to SES servers.\n\nPossible SES options are the following:\n\n * **AWSAccessKeyID** - AWS access key (required)\n * **AWSSecretKey** - AWS secret (required)\n * **ServiceUrl** - optional API end point URL (defaults to *\"https://email.us-east-1.amazonaws.com\"*)\n\nExample:\n\n```javascript\nvar transport = nodemailer.createTransport(\"SES\", {\n    AWSAccessKeyID: \"AWSACCESSKEY\",\n    AWSSecretKey: \"AWS/Secret/key\"\n});\n```\n\n### Setting up Sendmail\n\nSendmail transport method streams the compiled message to the *stdin* of *sendmail*\ncommand.\n\nOptions object is optional, possible sendmail options are the following:\n\n  * **path** - path to the `sendmail` command (defaults to *\"sendmail\"*)\n  * **args** - an array of extra command line options to pass to the `sendmail` command (ie. `[\"-f\", \"foo@blurdybloop.com\"]`).\n  * **noCR** - If set to true, the line ending character will be `\\n` instead of the default `\\r\\n` ending.\n\nCurrently the command to be spawned is built up like this: the command is either using `sendmail -i -f from_addr to_addr[]` (by default) or `sendmail -i list_of_args[]` (if `args` property was given). `-i` is ensured to be present on either case.\n\nIn the default case (no `args` defined) From and To addresses are either taken from `From`,`To`, `Cc` and `Bcc` properties or from the `envelope` property if one is present.\n\nBe wary when using the `args` property - no recipients are defined by default, you need to ensure these by yourself, for example by using the `-t` flag.\n\nExample:\n\n```javascript\nvar transport = nodemailer.createTransport(\"sendmail\");\n```\n\nor\n\n```javascript\nvar transport = nodemailer.createTransport(\"sendmail\", {\n    path: \"/usr/local/bin/sendmail\",\n    args: [\"-t\", \"-f\", \"foo@blurdybloop.com\"]\n});\n```\n\n**Compatibility notice**\n\nSome sendmail implementations require all line endings to be &lt;LF&gt;.  Set\n`noCR:true` in the options argument to circument this.\n\n\n### DKIM Signing\n\n**Nodemailer** supports DKIM signing with very simple setup. Use this with caution\nthough since the generated message needs to be buffered entirely before it can be\nsigned. Not a big deal with small messages but might consume a lot of RAM when\nusing larger attachments.\n\nSet up the DKIM signing with `useDKIM` method for a transport object:\n\n```javascript\ntransport.useDKIM(dkimOptions)\n```\n\nWhere `dkimOptions` includes necessary options for signing\n\n  * **domainName** - the domainname that is being used for signing\n  * **keySelector** - key selector. If you have set up a TXT record with DKIM public key at *zzz._domainkey.blurdybloop.com* then `zzz` is the selector\n  * **privateKey** - DKIM private key that is used for signing as a string\n  * **headerFieldNames** - optional colon separated list of header fields to sign, by default all fields suggested by RFC4871 #5.5 are used\n\nAll messages transmitted through this transport objects are from now on DKIM signed.\n\nCurrently if several header fields with the same name exists, only the last one (the one in the bottom) is signed.\n\nExample:\n\n```javascript\nvar transport = nodemailer.createTransport(\"Sendmail\");\n\ntransport.useDKIM({\n    domainName: \"kreata.ee\",\n    keySelector: \"dkim\",\n    privateKey: fs.readFileSync(\"private_key.pem\")\n});\n\ntransport.sendMail(mailOptions);\n```\n\nSee [examples/example_dkim.js](https://github.com/andris9/Nodemailer/blob/master/examples/example_dkim.js) for a complete example.\n\n### Well known services for SMTP\n\nIf you want to use a well known service as the SMTP host, you do not need\nto enter the hostname or port number, just use the `service` parameter\n\nCurrently supported services are:\n\n  * **DynectEmail**\n  * **Gmail**\n  * **hot.ee**\n  * **Hotmail**\n  * **iCloud**\n  * **mail.ee**\n  * **Mail.Ru**\n  * **Mailgun**\n  * **Mailjet**\n  * **Mandrill**\n  * **Postmark**\n  * **QQ**\n  * **QQex** (Tencent Business Email)\n  * **SendGrid**\n  * **SES**\n  * **Yahoo**\n  * **yandex**\n  * **Zoho**\n\nPredefined service data covers `host`, `port` and secure connection settings,\nany other parameters (ie. `auth`) need to be set separately. Service names are\ncase insensitive, so using \"gmail\" instead of \"Gmail\" is totally fine.\n\nExample:\n\n```javascript\nvar smtpTransport = nodemailer.createTransport(\"Gmail\",{\n    auth: {\n        user: \"gmail.user@gmail.com\",\n        pass: \"userpass\"\n    }\n});\n```\n\nor alternatively\n\n```javascript\nvar smtpTransport = nodemailer.createTransport(\"SMTP\",{\n    service: \"Gmail\", // sets automatically host, port and connection security settings\n    auth: {\n        user: \"gmail.user@gmail.com\",\n        pass: \"userpass\"\n    }\n});\n```\n\nActually, if you are authenticating with an e-mail address that has a domain name\nlike @gmail.com or @yahoo.com etc., then you don't even need to provide the service name,\nit is detected automatically.\n\n```javascript\nvar smtpTransport = nodemailer.createTransport(\"SMTP\",{\n    auth: {\n        user: \"gmail.user@gmail.com\", // service is detected from the username\n        pass: \"userpass\"\n    }\n});\n```\n\n## E-mail message fields\n\nThe following are the possible fields of an e-mail message:\n\n  - **from** - The e-mail address of the sender. All e-mail addresses can be plain `sender@server.com` or formatted `Sender Name <sender@server.com>`\n  - **to** - Comma separated list or an array of recipients e-mail addresses that will appear on the `To:` field\n  - **cc** - Comma separated list or an array of recipients e-mail addresses that will appear on the `Cc:` field\n  - **bcc** - Comma separated list or an array of recipients e-mail addresses that will appear on the `Bcc:` field\n  - **replyTo** - An e-mail address that will appear on the `Reply-To:` field\n  - **inReplyTo** - The message-id this message is replying\n  - **references** - Message-id list\n  - **subject** - The subject of the e-mail\n  - **text** - The plaintext version of the message\n  - **html** - The HTML version of the message\n  - **generateTextFromHTML** - if set to true uses HTML to generate plain text body part from the HTML if the text is not defined\n  - **headers** - An object of additional header fields `{\"X-Key-Name\": \"key value\"}` (NB! values are passed as is, you should do your own encoding to 7bit and folding if needed)\n  - **attachments** - An array of attachment objects.\n  - **alternatives** - An array of alternative text contents (in addition to text and html parts)\n  - **envelope** - optional SMTP envelope, if auto generated envelope is not suitable\n  - **messageId** - optional Message-Id value, random value will be generated if not set. Set to false to omit the Message-Id header\n  - **date** - optional Date value, current UTC string will be used if not set\n  - **encoding** - optional transfer encoding for the textual parts (defaults to \"quoted-printable\")\n  - **charset** - optional output character set for the textual parts (defaults to \"utf-8\")\n  - **dsn** - An object with methods `success`, `failure` and `delay`. If any of these are set to true, DSN will be used\n\nAll text fields (e-mail addresses, plaintext body, html body) use UTF-8 as the encoding.\nAttachments are streamed as binary.\n\nExample:\n\n```javascript\nvar transport = nodemailer.createTransport(\"Sendmail\");\n\nvar mailOptions = {\n    from: \"me@tr.ee\",\n    to: \"me@tr.ee\",\n    subject: \"Hello world!\",\n    text: \"Plaintext body\"\n}\n\ntransport.sendMail(mailOptions);\n```\n\n### SendGrid support\n\nNodemailer supports SendGrid [SMTP API](http://docs.sendgrid.com/documentation/api/smtp-api/) out of the box - you can\nuse objects as header values and these are automatically JSONized (and mime encoded if needed).\n\n```javascript\nvar mailOptions = {\n    ...,\n    headers: {\n        'X-SMTPAPI': {\n            category : \"newuser\",\n            sub:{\n                \"%name%\": [\"Žiguli Õllepruul\"]\n            }\n        }\n    },\n    subject: \"Hello, %name%\"\n}\n```\n\nThis also applies to any other service that expects a JSON string as a header value for specified key.\n\n### Generate Text from HTML\n\nIf `generateTextFromHTML` option is set to true, then HTML contents of the mail is automatically converted\nto plaintext format when plaintext content is empty or missing.\n\nFor example\n\n```javascript\nmailOptions = {\n    ...,\n    generateTextFromHTML: true,\n    html: '<h1>Hello world</h1><p><b>How</b> are you?',\n    // text: '' // no text part\n}\n```\n\nis automatically converted in the backround by Nodemailer to:\n\n```javascript\nmailOptions = {\n    ...,\n    // source html:\n    html: '<h1>Hello world</h1><p><b>How</b> are you?',\n    // automatically generated plaintext message:\n    text: \"Hello world\\n\"+\n          \"===========\\n\"+\n          \"\\n\"+\n          \"**How** are you?\"\n}\n```\n\nAs you can see the output syntax for `generateTextFromHTML` looks similar to markdown, and that\nis exactly the case here - Nodemailer includes a simple HTML to markdown converter. But don't\nexpect too much from it, it's not full featured or perfect, just some regexes here and there.\n\n### Attachment fields\n\nAttachment object consists of the following properties:\n\n  * **fileName** - filename to be reported as the name of the attached file, use of unicode is allowed (except when using Amazon SES which doesn't like it)\n  * **cid** - optional content id for using inline images in HTML message source\n  * **contents** - String or a Buffer contents for the attachment\n  * **filePath** - path to a file or an URL if you want to stream the file instead of including it (better for larger attachments)\n  * **streamSource** - Stream object for arbitrary binary streams if you want to stream the contents (needs to support *pause*/*resume*)\n  * **contentType** - optional content type for the attachment, if not set will be derived from the `fileName` property\n  * **contentDisposition** - optional content disposition type for the attachment, defaults to \"attachment\"\n\nOne of `contents`, `filePath` or `streamSource` must be specified, if none is\npresent, the attachment will be discarded. Other fields are optional.\n\nAttachments can be added as many as you want.\n\n```javascript\nvar mailOptions = {\n    ...\n    attachments: [\n        {   // utf-8 string as an attachment\n            fileName: \"text1.txt\",\n            contents: \"hello world!\"\n        },\n        {   // binary buffer as an attachment\n            fileName: \"text2.txt\",\n            contents: new Buffer(\"hello world!\",\"utf-8\")\n        },\n        {   // file on disk as an attachment\n            fileName: \"text3.txt\",\n            filePath: \"/path/to/file.txt\" // stream this file\n        },\n        {   // fileName and content type is derived from filePath\n            filePath: \"/path/to/file.txt\"\n        },\n        {   // stream as an attachment\n            fileName: \"text4.txt\",\n            streamSource: fs.createReadStream(\"file.txt\")\n        },\n        {   // define custom content type for the attachment\n            fileName: \"text.bin\",\n            contents: \"hello world!\",\n            contentType: \"text/plain\"\n        },\n        {   // use URL as an attachment\n            fileName: \"license.txt\",\n            filePath: \"https://raw.github.com/andris9/Nodemailer/master/LICENSE\"\n        }\n    ]\n}\n```\n\n\n## Tests\n\nRun the tests with npm in Nodemailer's directory\n\n```\nnpm test\n```\n\n## License\n\n**Fire-Mail** is licensed under the [MIT license](https://github.com/gintellect/fire-mail/blob/master/LICENSE). Basically you can do whatever you want to with it.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gintellect/fire-mail.git"
  },
  "scripts": {
    "test": "grunt test"
  },
  "version": "0.0.0"
}
